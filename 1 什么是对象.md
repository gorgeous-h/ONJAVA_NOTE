## 1.1 抽象的历程

所有编程语言都是一种抽象。

我们能够解决的问题的复杂程度直接取决于抽象的类型和质量。

程序员必须在机器模型和实际解决的问题模型之间建立关联。

面向对象编程描述问题的依据是实际的问题，而非用于执行解决方案的计算机。

每一个对象都具有状态，并且可以执行一些特定的操作。这一特点与现实中的事物极为相似，它们都具有各自的行为和特征。

SmallTalk是历史上第一门获得成功的面向对象语言，并且为后续出现的Java语言提供了灵感。

SmallTalk语言的5个基本特征：

1. **万物皆对象**。
2. **一段程序实际上就是多个对象通过发送消息来通知彼此要干什么**。当你向一个对象"发送消息"时，实际情况是你发送了一个请求去调用该对象的某个方法。
3. **从内存角度而言，每一个对象都是由其他更为基础的对象组成的**。
4. **每一个对象都有类型**。每一个对象都是通过某个**类**生成的**实例**。一个类最为显著的特征是"你可以发送什么消息给它"。
5. **同一类型的对象可以接收相同的消息**。

对象可以拥有属于自己的内部数据（赋予其状态）、方法（用于产生行为），同时每一个对象都有别于其他对象。也就是说，每一个对象在内存中都有唯一的地址。

## 1.2 对象具有接口

你可以创建某种类型的变量（在面向对象领域，这些变量叫作"对象"或"实例"），随后你就可以操作这些变量（叫作"发送消息"或"发送请求"，即你发送指令给对象，然后对象自行决定怎么处理）。

如何能让一个对象真正发挥其作用呢？答案是向对象发送请求，对象能够接受什么请求，是由它的"接口"（interface）决定的，而对象所归属的类定义了这些接口。

对于每一个请求，类都有一个方法与之对应。当你向一个对象发送特定的请求时，对应的方法就会被调用。

## 1.3 对象可以提供服务

当你开发一个面向对象程序或理解其设计时，一个上佳的方法是将对象想象成"服务提供者"。

在面向对象领域，出色的设计往往意味着一个对象只做好一件事，绝不贪多。

如果别人因为对象提供的服务而认识到它的价值，那么他就会更加轻松地在自己的设计中使用这个对象。

## 1.4 隐藏的实现

我们可以把程序员划分为两大阵营：

1. 类的创建者（负责创建新数据类型的人）
2. 客户程序员（在自己的应用程序里使用现有数据类型的人）

客户程序员的诉求是收集一个装满了各种类的工具箱，以便自己能够快速开发应用程序。

类的创建者则负责在创建新的类时，只暴露必要的接口给客户程序员，同时隐藏其他所有不必要的信息。

如果这些信息对于客户程序员而言是不可见的，那么类的创建者就可以任意修改隐藏的信息，而无须担心对其他任何人造成影响。

所有的关系都需要被相关各方一致遵守的边界。

当你创建了一个库，那么你就和使用它的客户程序员建立了一种关系。

如果一个类的所有成员都对所有人可见，那么客户程序员就可以恣意妄为，而且我们无法强制他遵守规定。

也许你的预期是客户程序员不会直接操作任何类的成员，但是如果没有访问控制的话，你就无法实现这一点，因为所有的一切都暴露在对方面前了。

我们**设置访问控制的首要原因**是防止客户程序员接触到他们本不该触碰的内容，这种做法实际上为客户程序员提供了一种服务，因为他们很容易就可以知道哪些信息对他们来说是重要的，哪些则是无须关心的。

**设置访问控制的第二个原因**则是，让库的设计者在改变类的内部工作机制时，不用担心影响到使用该类的客户程序员（接口和实现分离）。

设置访问控制的关键字叫作"访问修饰符"（access specifier）：

- `public`
- `private`
- `protected`

如果不使用任意一种修饰符，Java会提供一种默认访问权限，通常叫作"包访问"。

## 1.5 复用实现

如果一个类经过了充分测试，其代码就应该是有效且可复用的。

代码复用是我们使用面向对象编程的理由之一。

新创建的类可以由任意数量和类型的对象组成，也可以任意**组合**这些对象，以满足想要的功能。

组合通常代表一种"有"（has-a）的关系。

组合为我们提供了极大的灵活性。

编译器对使用继承创建的类设置了一些编译时的限制。

继承常被视为面向对象编程的重中之重。在创建新类时应该首先考虑组合，因为使用组合更为简单灵活，设计也更为清晰简洁。一旦你拥有了足够的经验，何时使用继承就会变得非常清晰了。

## 1.6 继承

对象可以根据定义的概念来封装数据和功能。

继承通过基类和子类的概念来表述这种相似性，即基类拥有的所有特征和行为都可以与子类共享。

通过继承，我们创建了一种"类型层次"（type hierarchy）以表述那些需要根据具体类型来解决的问题。

类型层次既体现了不同类之间的相似性，又展现了它们之间的差异。

继承已有的类将产生新类，这个新的子类不但会继承其基类的所有成员，而且更重要的是，子类也会继承基类的接口。

既然基类和子类拥有相同的基础接口，就必然存在接口的具体实现。这意味着，当一个对象接收到特定的消息时，就会执行对应的代码。如果你继承了一个类并且不做任何修改的话，这个基类的方法就会原封不动地被子类所继承。

基类的行为和你的预期不符，于是为子类添加新的方法以满足自己的需求。你需要慎重考虑是否基类也需要这些新的方法。

继承意味着为子类添加新的方法 [用于继承的关键字就是"扩展"（extends）]。

还有一种让新类产生差异化的方法更为重要，即修改基类已有方法的行为，我们称之为"重写"该方法。

如果想要重写一个方法，你可以在子类中对其进行重新定义。也就是说，你的预期是"我想通过相同的接口调用该方法，但是我希望它可以在新的类中实现不同的效果"。

## 1.7 多态

面向对象语言调用方法使用的机制是"后期绑定"。

当你向某个对象发送消息时，直到运行时才会确定哪一段代码会被调用。

编译器会确保被调用的方法是真实存在的，并对该方法的参数和返回值进行类型检查，但是它并不知道具体执行的是哪一段代码。

Java默认具备动态绑定特性，所以你无须借助于其他关键字或代码来实现多态。

我们编写一段描述多态的代码：

```java
void doSomething(Shape shape) {
    shape.erase();
    // ...
    shape.draw();
}
```

这个方法适用于任何`Shape`对象。

```java
Circle circle = new Circle();
Triangle triangle = new Triangle();
Line line = new Line();
doSomething(circle);
doSomething(triangle);
doSomething(line);
```

不管对象具体属于哪个类，`doSomething()`方法都可以正常运行。

## 1.8 单根层次结构

所有的类都默认继承自某个基类`Object`。

单根层次结构有利于实现垃圾收集器，这也是Java对比C++的一个重要改进。

## 1.9 集合

一般来说，你并不知道解决一个特定的问题需要用到多少个对象，也不知道这些对象会存在多久，这样就不知道申请多少内存空间。

创建一种新类型的对象来保存其他对象的引用，在大多数编程语言里，可以用数组做到这一点，在面向对象语言里，这种新对象通常叫作"集合"，它会根据你放入其中的内容自行调整空间。

优秀的面向对象语言都会提供一些集合作为语言的基础功能。Java在其标准库中提供了大量的集合。

### 参数化类型（泛型）

在Java 5之前，Java语言的集合所支持的是通用类型`Object`。当你添加一个对象引用到集合时，该对象会向上转型为`Object`，从而失去了其原本的特征。当你需要将其取出时，会获得一个`Object`类型的对象引用，这就不是当初的类型了。

Java 5新增的主要特性之一是支持参数化类型，也叫作"泛型"。你可以通过在一对尖括号中间加上类名来定义泛型。对于参数化的集合而言，编译器可以将集合定义为只接受放入`Shape`的对象，因此从集合也只能取出`Shape`对象。

```java
ArrayList<Shape> shapes = new ArrayList<>();
```

## 1.10 对象的创建和生命周期

每个对象的创建都要消耗一些资源，尤其是内存资源。当我们不再需要一个对象时，就要及时清理它，这样它占用的资源才能被释放并重复使用。

在内存池里动态创建对象，这个内存池叫作"堆"（heap）。

如果你需要创建一个对象，可以直接通过堆来创建。

Java只允许动态分配内存。每当你创建一个对象时，都需要使用`new`操作符创建一个对象的动态实例。

对于C++语言来说，你必须在编码时就明确何时销毁对象，否则万一你的代码出了差错，就会造成内存泄漏。Java语言的底层支持垃圾收集器机制，它会自动找到无用的对象并将其销毁。垃圾收集器提供了一种更高级的保障以防止潜在的内存泄漏，而正是内存泄漏导致了许多C++项目的失败。

## 1.11 异常处理

异常是从错误发生之处"抛出"的对象，而根据错误类型，它可以被对应的异常处理程序所"捕获"。

异常不允许被忽略，所以这就确保了异常一定会在必要的时候被处理。

异常为我们提供了一种可以让程序从糟糕的情况中恢复过来的方法。即便发生了意外，我们也还有机会修正问题以及让程序重新恢复运行，而不是只能结束程序了事，而这一点无疑会增强许多程序的稳健性。

## 1.12 总结

面向对象编程的一个令人愉悦之处在于，那些设计良好的程序，其代码总是易于阅读的。另外，因为许多问题都能够通过复用已有的库来解决，所以通常来说代码行数也不会太多。

