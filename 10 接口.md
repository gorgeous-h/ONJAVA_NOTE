## 10.1 抽象类和抽象方法

我们创建抽象类，是想通过一个公共接口来操作一组类。

`Instrument`仅表示接口，而不是特定的实现，仅创建一个`Instrument`对象并没有什么意义。

**抽象方法**没有方法体：

```jade
abstract void f();
```

包含抽象方法的类称为**抽象类**。如果一个类包含一个或多个抽象方法，则该类必须被定义为抽象类，否则编译器会产生错误消息。抽象类并不会强制要求其所有方法都是抽象的。

```java
abstract class Basic {
  abstract void unimplemented();
}
```

```java
public class AttemptToUseBasic {
  Basic b = new Basic();
  // error: Basic is abstract; cannot be instantiated
}
```

抽象类不能实例化。

如果一个新类型继承了抽象类，并希望能生成自己的对象，那它必须为基类中的所有抽象方法提供方法定义。如果不这样做，那么子类也是抽象的，编译器将强制你使用`abstract`关键字来限定这个子类。

```java
abstract class Basic2 extends Basic {
  int f() { return 111; }
  abstract void g();
  // unimplemented() still not implemented
}
```

接口里只允许有`public`方法，抽象类则几乎对访问权限没有什么限制。

```java
abstract class Instrument {
  private int i; // Storage allocated for each
  public abstract void play(Note n);
  public String what() { return "Instrument"; }
  public abstract void adjust();
}

class Wind extends Instrument {
  @Override public void play(Note n) {
    System.out.println("Wind.play() " + n);
  }
  @Override public String what() { return "Wind"; }
  @Override public void adjust() {
    System.out.println("Adjusting Wind");
  }
}

// ...

public class Music4 {
  // Doesn't care about type, so new types
  // added to the system still work right:
  static void tune(Instrument i) {
    // ...
    i.play(Note.MIDDLE_C);
  }
  static void tuneAll(Instrument[] e) {
    for(Instrument i : e)
      tune(i);
  }
  public static void main(String[] args) {
    // Upcasting during addition to the array:
    Instrument[] orchestra = {
      new Wind(),
      new Percussion(),
      new Stringed(),
      new Brass(),
      new Woodwind()
    };
    tuneAll(orchestra);
  }
}
/* Output:
Wind.play() MIDDLE_C
Percussion.play() MIDDLE_C
Stringed.play() MIDDLE_C
Brass.play() MIDDLE_C
Woodwind.play() MIDDLE_C
*/
```

## 10.2 接口定义

我们使用关键字`interface`来定义接口。接口只允许使用抽象方法。

```java
public interface PureInterface {
  int m1();
  void m2();
  double m3();
}
```

这里甚至不需要在方法上使用`abstract`关键字——因为它们在接口中，Java知道它们不能有方法体。

`interface`关键字创建了一个完全抽象的类，它确定了方法名、参数列表和返回类型，但不提供方法主体。

接口可以包含字段，但这些字段是隐式的`static`和`final`。

要创建一个符合特定接口的类，请使用`implements`关键字。

```java
interface Concept { // Package access
  void idea1();
  void idea2();
}

class Implementation implements Concept {
  @Override public void idea1() {
    System.out.println("idea1");
  }
  @Override public void idea2() {
    System.out.println("idea2");
  }
}
```

### 10.2.1 默认方法

```java
interface InterfaceWithDefault {
  void firstMethod();
  void secondMethod();
  default void newMethod() {
    System.out.println("newMethod");
  }
}
```

```java
public class Implementation2
implements InterfaceWithDefault {
  @Override public void firstMethod() {
    System.out.println("firstMethod");
  }
  @Override public void secondMethod() {
    System.out.println("secondMethod");
  }
  public static void main(String[] args) {
    InterfaceWithDefault i =
      new Implementation2();
    i.firstMethod();
    i.secondMethod();
    i.newMethod();
  }
}
/* Output:
firstMethod
secondMethod
newMethod
*/
```

如果使用`default`关键字来为`newMethod()`提供默认定义，则使用该接口的所有旧代码都可以继续工作，不用做任何变动。

### 10.2.2 多重继承

```java
import java.util.*;

interface One {
  default void first() { System.out.println("first"); }
}

interface Two {
  default void second() {
    System.out.println("second");
  }
}

interface Three {
  default void third() { System.out.println("third"); }
}

class MI implements One, Two, Three {}

public class MultipleInheritance {
  public static void main(String[] args) {
    MI mi = new MI();
    mi.first();
    mi.second();
    mi.third();
  }
}
/* Output:
first
second
third
*/
```

组合多个来源的实现。

```java
import java.util.*;

interface Bob1 {
  default void bob() {
    System.out.println("Bob1::bob");
  }
}

interface Bob2 {
  default void bob() {
    System.out.println("Bob2::bob");
  }
}

// class Bob implements Bob1, Bob2 {}
/* Produces:
error: class Bob inherits unrelated defaults
for bob() from types Bob1 and Bob2
class Bob implements Bob1, Bob2 {}
^
1 error
*/

interface Sam1 {
  default void sam() {
    System.out.println("Sam1::sam");
  }
}

interface Sam2 {
  default void sam(int i) {
    System.out.println(i * 2);
  }
}

// Works because the argument lists are distinct:
class Sam implements Sam1, Sam2 {}

interface Max1 {
  default void max() {
    System.out.println("Max1::max");
  }
}

interface Max2 {
  default int max() { return 47; }
}

// class Max implements Max1, Max2 {}
/* Produces:
error: types Max2 and Max1 are incompatible;
both define max(), but with unrelated return types
class Max implements Max1, Max2 {}
^
1 error
*/
```

编译器通过方法签名来区分不同的方法。

方法签名，包括名称和参数类型。

返回类型不是方法签名的一部分，因此不能用于区分两个方法。

### 10.2.3 接口中的静态方法

```java
public interface Operation {
  void execute();
  static void runOps(Operation... ops) {
    for(Operation op : ops)
      op.execute();
  }
  static void show(String msg) {
    System.out.println(msg);
  }
}
```

```java
class Heat implements Operation {
  @Override public void execute() {
    Operation.show("Heat");
  }
}

public class MetalWork {
  public static void main(String[] args) {
    // Must be defined in a static context
    // to access a method reference:
    Operation twist = new Operation() {
      public void execute() {
        Operation.show("Twist");
      }
    };
    Operation.runOps(
      new Heat(),                     // [1]
      new Operation() {               // [2]
        public void execute() {
          Operation.show("Hammer");
        }
      },
      twist::execute,                 // [3]
      () -> Operation.show("Anneal")  // [4]
    );
  }
}
/* Output:
Heat
Hammer
Twist
Anneal
*/
```

创建`Operation`的不同方式：

[1] 常规类`Heat`。

[2] 匿名类。

[3] 方法引用。

[4] Lambda表达式。

[4] 常规类`Heat`。





